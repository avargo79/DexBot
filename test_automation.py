#!/usr/bin/env python3"""DexBot Phase 1 Interactive Test AutomationThis module provides interactive testing capabilities for DexBot's core systems.Designed to work with VS Code tasks for streamlined development workflow."""import jsonimport osimport sysimport tracebackfrom datetime import datetimefrom pathlib import Pathfrom typing import Any, Dict, List, Optionalclass DexBotTestRunner:    """Interactive test runner for DexBot Phase 1 systems."""        def __init__(self):        """Initialize the test runner."""        self.results: Dict[str, Any] = {            "timestamp": datetime.now().isoformat(),            "test_session": "Phase 1 Interactive Tests",            "tests": [],            "summary": {                "total": 0,                "passed": 0,                "failed": 0,                "skipped": 0            }        }            def run_import_tests(self) -> bool:        """Test that all core DexBot modules can be imported."""        print("=== Testing Module Imports ===")                modules_to_test = [            "src.config.config_manager",            "src.core.logger",             "src.systems.auto_heal",            "src.systems.combat",            "src.systems.looting",            "src.utils.uo_items"        ]                all_passed = True                for module_name in modules_to_test:            try:                __import__(module_name)                print(f"[PASS] {module_name}")                self._add_test_result(f"Import {module_name}", "PASS")            except Exception as e:                print(f"[FAIL] {module_name}: {e}")                self._add_test_result(f"Import {module_name}", "FAIL", str(e))                all_passed = False                        return all_passed        def run_config_tests(self) -> bool:        """Test configuration loading."""        print("\n=== Testing Configuration Loading ===")                try:            from src.config.config_manager import ConfigManager            config_manager = ConfigManager()                        # Test main config            main_config = config_manager.main_config            print(f"[PASS] Main config loaded: {len(main_config)} settings")            self._add_test_result("Load main config", "PASS")                        # Test system configs - only test looting since it has a getter method            try:                looting_config = config_manager.get_looting_config()                print(f"[PASS] looting config loaded: {len(looting_config)} settings")                self._add_test_result(f"Load looting config", "PASS")            except Exception as e:                print(f"[FAIL] looting config failed: {e}")                self._add_test_result(f"Load looting config", "FAIL", str(e))                return False                        # Test other configs by checking if they exist as properties            for system in ["auto_heal_config", "combat_config"]:                try:                    config = getattr(config_manager, system)                    print(f"[PASS] {system} loaded: {len(config)} settings")                    self._add_test_result(f"Load {system}", "PASS")                except Exception as e:                    print(f"[FAIL] {system} failed: {e}")                    self._add_test_result(f"Load {system}", "FAIL", str(e))                    return False                        return True                    except Exception as e:            print(f"[FAIL] Configuration test failed: {e}")            self._add_test_result("Configuration loading", "FAIL", str(e))            return False        def run_uo_items_tests(self) -> bool:        """Test UO Items database functionality."""        print("\n=== Testing UO Items Database ===")                try:            from src.utils.uo_items import UOItemDatabase                        # Test database loading            db = UOItemDatabase()            stats = db.get_database_stats()            print(f"[PASS] Database loaded: {stats['total_items']} items in {stats['total_categories']} categories")            self._add_test_result("Load UO Items database", "PASS")                        # Test basic operations            categories = db.get_available_categories()            print(f"[PASS] Found {len(categories)} categories")            self._add_test_result("Get categories", "PASS")                        # Test search functionality            if categories:                first_category = categories[0]                items = db.get_items_by_category(first_category)                print(f"[PASS] Category '{first_category}': {len(items)} items")                self._add_test_result(f"Get items by category", "PASS")                        return True                    except Exception as e:            print(f"[FAIL] UO Items test failed: {e}")            self._add_test_result("UO Items database", "FAIL", str(e))            traceback.print_exc()            return False        def run_build_test(self) -> bool:        """Test that DexBot can be built successfully."""        print("\n=== Testing Build Process ===")                try:            # Check if build output exists            build_output = Path("dist/DexBot.py")            if build_output.exists():                size_kb = build_output.stat().st_size / 1024                print(f"[PASS] Build output exists: {size_kb:.1f} KB")                self._add_test_result("Build output exists", "PASS")                                # Quick syntax check of build output                with open(build_output, 'r', encoding='utf-8') as f:                    content = f.read()                                    # Check for critical components                checks = [                    ("Main function", "def run_dexbot():" in content),                    ("UO Items", "class UOItemDatabase" in content),                    ("Config Manager", "class ConfigManager" in content),                    ("Looting System", "class LootingSystem" in content)                ]                                for check_name, check_result in checks:                    if check_result:                        print(f"[PASS] {check_name} found in build")                        self._add_test_result(f"Build contains {check_name}", "PASS")                    else:                        print(f"[FAIL] {check_name} missing from build")                        self._add_test_result(f"Build contains {check_name}", "FAIL")                        return False                                return True            else:                print("[FAIL] Build output not found - run build first")                self._add_test_result("Build output exists", "FAIL", "dist/DexBot.py not found")                return False                        except Exception as e:            print(f"[FAIL] Build test failed: {e}")            self._add_test_result("Build test", "FAIL", str(e))            return False        def _add_test_result(self, name: str, status: str, error: Optional[str] = None):        """Add a test result to the results."""        result = {            "name": name,            "status": status,            "timestamp": datetime.now().isoformat()        }        if error:            result["error"] = error                    self.results["tests"].append(result)        self.results["summary"]["total"] += 1                if status == "PASS":            self.results["summary"]["passed"] += 1        elif status == "FAIL":            self.results["summary"]["failed"] += 1        else:            self.results["summary"]["skipped"] += 1        def save_results(self) -> str:        """Save test results to a JSON file."""        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")        filename = f"tmp/test_results_interactive_{timestamp}.json"                with open(filename, 'w') as f:            json.dump(self.results, f, indent=2)                    return filename        def print_summary(self):        """Print test summary."""        summary = self.results["summary"]        total = summary["total"]        passed = summary["passed"]        failed = summary["failed"]                print(f"\n=== Test Summary ===")        print(f"Total Tests: {total}")        print(f"Passed: {passed}")        print(f"Failed: {failed}")        print(f"Success Rate: {(passed/total*100):.1f}%" if total > 0 else "N/A")                if failed > 0:            print(f"\nFailed Tests:")            for test in self.results["tests"]:                if test["status"] == "FAIL":                    print(f"  - {test['name']}: {test.get('error', 'Unknown error')}")def main():    """Run the interactive test suite."""    print("DexBot Phase 1 Interactive Test Suite")    print("=" * 40)        runner = DexBotTestRunner()        # Run test phases    tests_passed = 0    total_phases = 4        if runner.run_import_tests():        tests_passed += 1            if runner.run_config_tests():        tests_passed += 1            if runner.run_uo_items_tests():        tests_passed += 1            if runner.run_build_test():        tests_passed += 1        # Print summary    runner.print_summary()        # Save results    results_file = runner.save_results()    print(f"\nResults saved to: {results_file}")        # Overall result    if tests_passed == total_phases:        print("\n[SUCCESS] All test phases passed! DexBot is ready for RazorEnhanced.")        return 0    else:        print(f"\n[WARNING] {total_phases - tests_passed} test phase(s) failed. Check output above.")        return 1if __name__ == "__main__":    sys.exit(main())