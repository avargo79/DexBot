# DexBot Development Tasks Configuration
# Structured guidance for common development tasks and patterns

metadata:
  version: "1.0"
  created: "2025-07-03"
  purpose: "Task-specific guidance for AI assistants working on DexBot"

# Task templates with specific guidance
task_templates:
  
  new_system_implementation:
    description: "Creating a new bot system (healing, combat, looting, etc.)"
    requirements:
      config: "Create JSON config file in config/"
      implementation: "Main system class in src/systems/"
      tests: "3-case test suite in tests/"
      ui: "GUMP interface if user-facing"
      docs: "Update relevant documentation"
    
    code_patterns:
      system_class_template: |
        class NewSystem:
            def __init__(self, config_manager):
                self.config = config_manager
                self.logger = Logger()
                self.enabled = self.config.get_setting('new_system.enabled', False)
            
            def update(self):
                if not self.enabled:
                    return
                try:
                    # Main system logic here
                    pass
                except Exception as e:
                    self.logger.error(f"NewSystem error: {e}")
      
      config_template: |
        {
          "enabled": false,
          "update_interval_ms": 1000,
          "settings": {
            "example_setting": "default_value"
          }
        }
    
    testing_pattern: |
      def test_new_system_pass_case(self):
          # Test successful operation
      def test_new_system_fail_case(self):
          # Test error conditions
      def test_new_system_edge_case(self):
          # Test boundary conditions
  
  performance_optimization:
    description: "Optimizing existing systems for better performance"
    focus_areas:
      api_calls: "Reduce unnecessary RazorEnhanced API calls"
      memory: "Optimize memory usage for long sessions"
      loops: "Improve update loop efficiency"
      caching: "Implement smart caching strategies"
    
    measurement_tools:
      profiling: "Use performance_profile_*.md reports"
      timing: "Add timing logs for critical sections"
      memory: "Monitor memory usage patterns"
    
    optimization_patterns:
      api_call_reduction: |
        # Cache API results when possible
        if not hasattr(self, '_cached_value') or self._should_refresh_cache():
            self._cached_value = expensive_api_call()
        return self._cached_value
      
      ignore_list_optimization: |
        # Use ignore lists to avoid repeated processing
        if item_serial in self.ignore_list:
            return False
        if not self._is_valuable_item(item):
            self.ignore_list.add(item_serial)
            return False
  
  bug_investigation:
    description: "Systematic approach to investigating and fixing bugs"
    investigation_steps:
      1. "Reproduce the issue consistently"
      2. "Check logs for error patterns"
      3. "Identify the affected system"
      4. "Create minimal test case"
      5. "Implement fix with proper error handling"
      6. "Add test to prevent regression"
    
    common_bug_patterns:
      api_failures: "RazorEnhanced API returns None or throws exception"
      timing_issues: "Race conditions in update cycles"
      memory_leaks: "Objects not properly cleaned up"
      config_errors: "Invalid configuration values"
    
    debugging_tools:
      logging: "Use Logger.debug() for detailed tracing"
      validation: "Run invoke validate after changes"
      testing: "Use invoke test to verify fix"
  
  testing_implementation:
    description: "Creating comprehensive tests for DexBot systems"
    test_structure:
      setup: "Mock RazorEnhanced APIs and dependencies"
      teardown: "Clean up mocks and temporary data"
      assertions: "Verify expected behavior and side effects"
    
    mock_patterns:
      razorenhanced_mock: |
        class MockPlayer:
            Hits = 100
            HitsMax = 100
            Name = "TestPlayer"
        
        # Replace RazorEnhanced.Player with mock during tests
      
      config_mock: |
        test_config = {
            "system": {
                "enabled": True,
                "setting": "test_value"
            }
        }
    
    coverage_targets:
      minimum: "90% code coverage"
      preferred: "96%+ code coverage"
      critical_systems: "100% coverage for auto_heal, combat, looting"

# System-specific guidance
system_guidance:
  
  auto_heal:
    critical_functions:
      - "heal_player(): Core healing logic"
      - "check_bandage_healing(): Bandage management"
      - "use_heal_potion(): Potion usage"
    performance_notes:
      - "Called every 100ms in main loop"
      - "Must be extremely efficient"
      - "Cache player status when possible"
    common_issues:
      - "Bandage timing conflicts"
      - "Potion cooldown management"
      - "Player status detection"
  
  combat:
    critical_functions:
      - "find_targets(): Enemy detection"
      - "engage_target(): Combat engagement"
      - "update_combat_state(): State management"
    performance_notes:
      - "Target scanning is expensive"
      - "Use ignore lists for dead/invalid targets"
      - "Optimize distance calculations"
    common_issues:
      - "Target disappearing during combat"
      - "Distance calculation accuracy"
      - "Line of sight validation"
  
  looting:
    critical_functions:
      - "find_corpses(): Corpse detection"
      - "evaluate_item(): Item value assessment"
      - "loot_corpse(): Item collection"
    performance_notes:
      - "90% optimization achieved through ignore lists"
      - "Item evaluation must be fast"
      - "Corpse scanning optimization critical"
    common_issues:
      - "Corpse access permissions"
      - "Inventory space management"
      - "Item weight calculations"

# Code review checklist for AI
code_review_checklist:
  functionality:
    - "Does the code fulfill its intended purpose?"
    - "Are all edge cases handled appropriately?"
    - "Is error handling comprehensive?"
  
  performance:
    - "Are API calls minimized and cached?"
    - "Is the code efficient for 12+ hour sessions?"
    - "Are expensive operations avoided in tight loops?"
  
  maintainability:
    - "Is the code readable and well-documented?"
    - "Are naming conventions followed?"
    - "Is the code modular and testable?"
  
  reliability:
    - "Are all RazorEnhanced API calls wrapped in try/catch?"
    - "Is graceful degradation implemented?"
    - "Are timeouts and retries handled properly?"

# Common pitfalls and solutions
common_pitfalls:
  
  razorenhanced_api:
    issue: "API calls returning None unexpectedly"
    solution: "Always check for None and implement fallbacks"
    pattern: |
      try:
          result = RazorEnhanced.Player.Hits
          if result is None:
              self.logger.warning("Player.Hits returned None")
              return self.last_known_hits
          return result
      except Exception as e:
          self.logger.error(f"Failed to get player hits: {e}")
          return self.last_known_hits
  
  memory_management:
    issue: "Memory usage grows over long sessions"
    solution: "Implement proper cleanup and garbage collection"
    pattern: |
      def cleanup_old_data(self):
          # Remove old entries from caches
          current_time = time.time()
          self.cache = {k: v for k, v in self.cache.items() 
                       if current_time - v.timestamp < self.cache_ttl}
  
  configuration_errors:
    issue: "Invalid config values causing crashes"
    solution: "Validate all config values with defaults"
    pattern: |
      def get_validated_setting(self, key, default, validator=None):
          value = self.config.get_setting(key, default)
          if validator and not validator(value):
              self.logger.warning(f"Invalid config value for {key}: {value}")
              return default
          return value

# Integration patterns
integration_patterns:
  
  system_communication:
    description: "How systems communicate with each other"
    pattern: "Event-driven communication through main bot controller"
    example: |
      # Combat system notifies healing system of damage
      self.bot_controller.notify_event('player_damaged', damage_amount)
  
  configuration_management:
    description: "Centralized configuration access"
    pattern: "All systems use ConfigManager for settings"
    example: |
      self.enabled = self.config.get_setting('combat.enabled', False)
      self.aggro_range = self.config.get_setting('combat.aggro_range', 8)
  
  error_propagation:
    description: "How errors flow through the system"
    pattern: "Log locally, notify globally for critical errors"
    example: |
      try:
          critical_operation()
      except CriticalError as e:
          self.logger.error(f"Critical error: {e}")
          self.bot_controller.handle_critical_error(e)
          raise
